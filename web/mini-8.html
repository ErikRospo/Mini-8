<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>MiniMachineVM</title>
    <style>
        body {
            font-family: monospace;
            background: #111;
            color: #0f0;
            margin: 0;
            padding: 10px;
        }

        .top-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            padding-bottom: 10px;
            border-bottom: 1px solid #0f0;
        }

        .registers {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }

        .register {
            min-width: 60px;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        textarea {
            background: #000;
            color: #0f0;
            padding: 10px;
            border: 1px solid #0f0;
            resize: vertical;
            min-height: 300px;
            font-family: monospace;
        }

        pre {
            background: #000;
            padding: 10px;
            border: 1px solid #0f0;
            overflow-x: auto;
            white-space: pre-wrap;
            flex: 1;
        }

        button,
        input[type="checkbox"] {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 4px 8px;
            cursor: pointer;
        }

        button:disabled {
            opacity: 0.5;
        }

    .dis-line {
        position: relative;
        padding-left: 2em;
        white-space: pre;
    }

    .dis-line::before {
        content: var(--line-num);
        position: absolute;
        left: 0;
        color: #0f0;
        opacity: 0.5;
        pointer-events: none;
        user-select: none;
    }
    </style>
</head>

<body>
    <div class="top-bar">
        <div class="registers" id="registers">
            <!-- Registers rendered here -->
        </div>
        <div class="controls">
            <button id="playPauseBtn">Play</button>
            <button id="stepBtn">Step</button>
            <input type="file" id="fileInput" style="display:none" accept=".bin,.mi8" />
            <button id="loadBtn">Load File</button>
            <button id="formatBtn">Format</button>
        </div>
    </div>

    <div class="panel-container">
        <div class="panel">
            <h2>Raw Code</h2>
            <textarea id="rawCodeInput" spellcheck="false"></textarea>
        </div>
        <div class="panel">
            <h2>Disassembly</h2>
            <pre id="disasm"></pre>
        </div>
    </div>
    <script>
        class MiniMachineVM {
            constructor(program) {
                this.reg = new Array(8).fill(0); // r0-r7
                this.ram = new Array(256).fill(0);
                this.stack = [];
                this.program = program;
                this.halted = false;
                this.PC = 7; // r7 is PC
            }

            fetch() {
                const pc = this.reg[this.PC];
                const idx = pc * 4;
                if (idx + 4 > this.program.length) {
                    this.halted = true;
                    return null;
                }
                return this.program.slice(idx, idx + 4);
            }

            getOperand(val, isImm) {
                return isImm ? val : this.reg[val & 0x7];
            }

            setReg(idx, value) {
                if (idx === 6) return; // r6 is reserved
                this.reg[idx] = value & 0xFF;
            }

            wrt(val, fmt) {
                let ch = "";
                switch (fmt) {
                    case 0:
                        ch = val === 0 ? "\n" : String.fromCharCode(val);
                        break;
                    case 1:
                        ch = val <= 9 ? val.toString() : "?";
                        break;
                    case 2:
                        ch = val <= 25 ? String.fromCharCode(65 + val) : "?";
                        break;
                    case 3:
                        ch = val <= 15 ? val.toString(16).toUpperCase() : "?";
                        break;
                }
                printOutput(ch);
            }

            execute(instr) {
                const [opcode, op1, op2, dest] = instr;
                const imm1 = (opcode >> 6) & 1;
                const imm2 = (opcode >> 5) & 1;
                const opclass = (opcode >> 3) & 0x3;
                const subtype = opcode & 0x7;

                // ALU
                if (opclass === 0b00) {
                    let a = this.getOperand(op1, imm1);
                    let b = this.getOperand(op2, imm2);
                    let res = 0;
                    switch (subtype) {
                        case 0: res = a & b; break;
                        case 1: res = ((a >>> (b % 8)) | (a << (8 - (b % 8)))) & 0xFF; break;
                        case 2: res = (a + b) & 0xFF; break;
                        case 3: res = a ^ b; break;
                        case 4: res = a | b; break;
                        case 5: res = ((a << (b % 8)) | (a >>> (8 - (b % 8)))) & 0xFF; break;
                        case 6: res = (a - b) & 0xFF; break;
                        case 7: res = (~a) & 0xFF; break;
                    }
                    this.setReg(dest & 0x7, res);
                    this.reg[this.PC] = (this.reg[this.PC] + 1) % 256;
                    return;
                }

                // COND
                if (opclass === 0b01) {
                    let jump = false;
                    let a = this.getOperand(op1, imm1);
                    let b = this.getOperand(op2, imm2);
                    switch (subtype) {
                        case 0: jump = true; break;
                        case 1: jump = a !== b; break;
                        case 2: jump = a >= b; break;
                        case 3: jump = a > b; break;
                        case 4: jump = false; break;
                        case 5: jump = a === b; break;
                        case 6: jump = a < b; break;
                        case 7: jump = a <= b; break;
                    }
                    if (jump) {
                        this.setReg(this.PC, dest);
                    } else {
                        this.reg[this.PC] = (this.reg[this.PC] + 1) % 256;
                    }
                    return;
                }

                // IO
                if (opclass === 0b10) {
                    switch (subtype) {
                        case 0: {
                            const val = this.getOperand(op1, imm1);
                            this.setReg(dest & 0x7, val);
                            break;
                        }
                        case 1: {
                            const idx1 = op1 & 0x7;
                            const idx2 = dest & 0x7;
                            if (idx1 !== 6 && idx2 !== 6) {
                                [this.reg[idx1], this.reg[idx2]] = [this.reg[idx2], this.reg[idx1]];
                            }
                            break;
                        }
                        case 2: {
                            const val = this.getOperand(op1, imm1);
                            this.stack.push(val);
                            break;
                        }
                        case 3: {
                            if (this.stack.length > 0) {
                                this.setReg(dest & 0x7, this.stack.pop());
                            }
                            break;
                        }
                        case 4: {
                            const val = this.getOperand(op1, imm1);
                            const fmt = op2 & 0x3;
                            this.wrt(val, fmt);
                            break;
                        }
                        case 5: {
                            const addr = this.getOperand(op1, imm1);
                            this.stack.push(this.reg[this.PC]);
                            this.setReg(this.PC, addr);
                            return;
                        }
                        case 6: {
                            let offset = this.reg[0];
                            if (offset >= 0x80) offset -= 0x100;
                            this.setReg(this.PC, (this.reg[this.PC] + offset) & 0xFF);
                            return;
                        }
                        case 7: {
                            this.halted = true;
                            return;
                        }
                    }
                    this.reg[this.PC] = (this.reg[this.PC] + 1) % 256;
                }
            }
            renderRegisters() {
                const names = ["r0", "r1", "r2", "r3", "r4", "r5", "r6", "PC"];
                let out = names.map((n, i) => `${n}: ${this.reg[i].toString(16).padStart(2, "0")}`).join("  ");
                document.getElementById("registers").textContent = out;
            }


            run() {
                while (!this.halted) {
                    const instr = this.fetch();
                    if (!instr) break;
                    this.execute(instr);
                }
                printOutput("\n[Program Halted]\n");
            }

            step() {
                if (this.halted) return;
                const instr = this.fetch();
                if (!instr) {
                    this.halted = true;
                    return;
                }
                this.execute(instr);
            }
            disassemble(opcode, op1, op2, dest) {
                const imm1 = (opcode >> 6) & 1;
                const imm2 = (opcode >> 5) & 1;
                const opclass = (opcode >> 3) & 0x3;
                const subtype = opcode & 0x7;

                const regName = idx => `r${idx & 0x7}`;
                const opVal = (val, imm) => imm ? `0x${val.toString(16).toUpperCase()}` : regName(val);

                const immStr = `_${imm1 ? 'i' : 'r'}${imm2 ? 'i' : 'r'}`;

                if (opclass === 0b00) {
                    // ALU
                    const aluOps = ["AND", "ROR", "ADD", "XOR", "OR", "ROL", "SUB", "NOT"];
                    const op = aluOps[subtype] || "???";
                    if (op === "NOT") {
                        return `${op} ${opVal(op1, imm1)}, ${regName(dest)}`;
                    } else {
                        return `${op} ${opVal(op1, imm1)}, ${opVal(op2, imm2)}, ${regName(dest)}`;
                    }
                } else if (opclass === 0b01) {
                    // COND
                    const condOps = ["JMP", "JNE", "JGE", "JGT", "NOP", "JEQ", "JLT", "JLE"];
                    const op = condOps[subtype] || "???";
                    if (op === "JMP") {
                        return `${op} 0x${dest.toString(16).toUpperCase()}`;
                    } else if (op === "NOP") {
                        return `${op}`;
                    } else {
                        return `${op} ${opVal(op1, imm1)}, ${opVal(op2, imm2)}, 0x${dest.toString(16).toUpperCase()}`;
                    }
                } else if (opclass === 0b10) {
                    // IO
                    const ioOps = ["MOV", "SWAP", "PUSH", "POP", "WRT", "CALL", "JRE", "HCF"];
                    const op = ioOps[subtype] || "???";
                    if (op === "MOV") {
                        return `${op} ${opVal(op1, imm1)}, ${regName(dest)}`;
                    } else if (op === "SWAP") {
                        return `${op} ${regName(op1)}, ${regName(dest)}`;
                    } else if (op === "PUSH") {
                        return `${op} ${opVal(op1, imm1)}`;
                    } else if (op === "POP") {
                        return `${op} ${regName(dest)}`;
                    } else if (op === "WRT") {
                        const fmt = op2 & 0x3;
                        let op1Str;
                        if (imm1) {
                            if (fmt === 0) { // ASC
                                if (op1 === 0) {
                                    op1Str = '0x00';
                                } else if (op1 < 32 || op1 > 126 || op1 === 34 || op1 === 44) {
                                    op1Str = `0x${op1.toString(16).toUpperCase().padStart(2, "0")}`;
                                } else {
                                    op1Str = `"${String.fromCharCode(op1)}"`;
                                }
                            } else if (fmt === 1) { // DEC
                                op1Str = op1.toString(10);
                            } else if (fmt === 2) { // ALP
                                op1Str = op1.toString(10);
                            } else if (fmt === 3) { // HEX
                                op1Str = `0x${op1.toString(16).toUpperCase().padStart(2, "0")}`;
                            }
                        } else {
                            op1Str = regName(op1);
                        }
                        return `${op} ${op1Str}, 0b${fmt.toString(2).padStart(2,"0")}`;
                    } else if (op === "CALL") {
                        return `${op} ${opVal(op1, imm1)}`;
                    } else if (op === "JRE" || op === "HCF") {
                        return `${op}`;
                    } else {
                        return `${op} ???`;
                    }
                } else {
                    return "???";
                }
            }
        }
    </script>

    <script>
        let interval = null;
        let vm = null;

        const playPauseBtn = document.getElementById('playPauseBtn');
        const stepBtn = document.getElementById('stepBtn');
        const rawCodeInput = document.getElementById('rawCodeInput');
        const disasmEl = document.getElementById('disasm');
        const registersEl = document.getElementById('registers');

        playPauseBtn.addEventListener('click', () => {
            if (interval) {
                clearInterval(interval);
                interval = null;
                playPauseBtn.textContent = 'Play';
            } else {
                if (!vm) loadVMFromRaw();
                interval = setInterval(() => {
                    vm.step();
                    render();
                    if (vm.halted) {
                        clearInterval(interval);
                        playPauseBtn.textContent = 'Play';
                    }
                }, 1000);
                playPauseBtn.textContent = 'Pause';
            }
        });
        const fileInput = document.getElementById('fileInput');
        const loadBtn = document.getElementById('loadBtn');

        loadBtn.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (evt) {
                const buffer = evt.target.result;
                // Convert ArrayBuffer to hex string
                const bytes = new Uint8Array(buffer);
                const text = Array.from(bytes)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join(' ');
                rawCodeInput.value = text;
                vm = null;
                updateDisassembly();
            };
            reader.readAsArrayBuffer(file);
        });
        stepBtn.addEventListener('click', () => {
            if (!vm) loadVMFromRaw();
            vm.step();
            render();
        });

        rawCodeInput.addEventListener('input', () => {
            vm = null; // Reset VM when code changes
            updateDisassembly();
        });
        rawCodeInput.addEventListener('dragover', (e) => {
            e.preventDefault();
            rawCodeInput.style.background = '#222'; // Visual feedback
        });

        rawCodeInput.addEventListener('dragleave', (e) => {
            e.preventDefault();
            rawCodeInput.style.background = '#000';
        });

        rawCodeInput.addEventListener('drop', (e) => {
            e.preventDefault();
            rawCodeInput.style.background = '#000';
            const file = e.dataTransfer.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (evt) {
                const buffer = evt.target.result;
                // Convert ArrayBuffer to hex string
                const bytes = new Uint8Array(buffer);
                const text = Array.from(bytes)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join(' ');
                rawCodeInput.value = text;
                vm = null;
                updateDisassembly();
            };
            reader.readAsArrayBuffer(file);
        });

        const formatBtn = document.getElementById('formatBtn');
        formatBtn.addEventListener('click', () => {
            // Remove all non-hex chars and condense to a single string
            let hexStr = rawCodeInput.value.replace(/[^0-9a-fA-F]/g, '').toUpperCase();

            // Split into 2-char bytes
            let bytes = [];
            for (let i = 0; i < hexStr.length; i += 2) {
                bytes.push(hexStr.substr(i, 2));
            }

            // Format into lines of 4 bytes each
            let lines = [];
            for (let i = 0; i < bytes.length; i += 4) {
                lines.push(bytes.slice(i, i + 4).join(' '));
            }
            rawCodeInput.value = lines.join('\n');
            vm = null;
            updateDisassembly();
        });

        function loadVMFromRaw() {
            const bytes = rawCodeInput.value
                .trim()
                .split(/\s+/)
                .map(b => parseInt(b, 16) || 0);
            vm = new MiniMachineVM(new Uint8Array(bytes));
            render();
        }

        function updateDisassembly() {
            const bytes = rawCodeInput.value
                .trim()
                .split(/\s+/)
                .map(b => parseInt(b, 16) || 0);
            let html = '';
            for (let i = 0, line = 1; i + 3 < bytes.length; i += 4, line++) {
                const instr = bytes.slice(i, i + 4);
                const dis = MiniMachineVM.prototype.disassemble(...instr);
                html += `<span class="dis-line" style="--line-num: '${line.toString(16).padStart(2,'0').toUpperCase()}'">${dis}</span>\n`;

            }
            disasmEl.innerHTML = html;
        }

        function render() {
            // Registers
            const names = ['r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'PC'];
            registersEl.innerHTML = '';
            names.forEach((n, i) => {
                if (n == 'r6') {
                    return
                }
                const val = vm ? vm.reg[i].toString(16).padStart(2, '0') : '00';
                const div = document.createElement('div');
                div.className = 'register';
                div.textContent = `${n}: ${val}`;
                registersEl.appendChild(div);
            });
            updateDisassembly();
        }

        render()

    </script>
</body>

</html>