<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>MiniMachineVM</title>
    <style>
        body {
            font-family: monospace;
            background: #111;
            color: #0f0;
            margin: 0;
            padding: 10px;
            font-size: large;
        }

        .top-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            padding-bottom: 10px;
            border-bottom: 1px solid #0f0;
        }

        .current-pc {
            background: #0f0;
            color: #111;
        }

        .current-pc.dis-line::before {
            color: #111;
            font-weight: bold;
        }

        .registers {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            font-size: larger;
        }

        .register {
            min-width: 60px;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        textarea {
            background: #000;
            color: #0f0;
            padding: 10px;
            border: 1px solid #0f0;
            resize: vertical;
            min-height: 300px;
            font-family: monospace;
        }

        pre {
            background: #000;
            padding: 10px;
            border: 1px solid #0f0;
            overflow-x: auto;
            white-space: pre-wrap;
            flex: 1;
        }

        button,
        input[type="checkbox"] {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 4px 8px;
            cursor: pointer;
        }

        button:disabled {
            opacity: 0.5;
        }

        input[type="number"] {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 4px 8px;
            cursor: pointer;
            font-family: inherit;
        }

        /* Optional: Remove spinner arrows in Chrome, Edge, Safari */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Optional: Remove spinner arrows in Firefox */
        input[type="number"] {
            -moz-appearance: textfield;
            appearance: textfield;
        }


        #output {
            min-height: 100px;
        }

        #ram {
            min-height: 90px;
            overflow-x: auto;
            white-space: pre-wrap;
            flex: 1;
        }

        #stack {
            min-height: 100px;
        }

        .txtbx {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            font-family: monospace;
            white-space: pre;
            overflow-y: auto;
            outline: none;
        }

        .disasm-editor {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            font-family: monospace;
            white-space: pre;
            min-height: 300px;
            overflow-y: auto;
            outline: none;
        }

        .disasm-editor .dis-line {
            position: relative;
            padding-left: 2em;
            white-space: pre;
            display: block;
        }

        .disasm-editor .dis-line::before {
            content: attr(data-line);
            position: absolute;
            left: 0;
            color: #0f0;
            opacity: 0.5;
            pointer-events: none;
            user-select: none;
        }

        .disasm-editor .current-pc {
            background-color: #0f0;
            color: #111;
            font-weight: bold;
        }

        .disasm-editor .current-pc.dis-line::before {
            color: #000;
            font-weight: bold;
        }


        .dis-line {
            position: relative;
            padding-left: 2em;
            white-space: pre;
        }

        .dis-line::before {
            content: var(--line-num);
            position: absolute;
            left: 0;
            color: #0f0;
            opacity: 0.5;
            pointer-events: none;
            user-select: none;
        }

        .register.flash {
            color: #000;
            background-color: #0f0;
        }
    </style>
</head>

<body>
    <div class="top-bar">

        <div class="controls">
            <button id="playPauseBtn">Play</button>
            <button id="stepBtn">Step</button>

            <input type="file" id="fileInput" style="display:none" accept=".bin,.mi8" />
            <button id="loadBtn">Load File</button>
            <button id="formatBtn">Format</button>
            <button id="assembleBtn">Assemble</button>

            <button id="documentation">Documentation/ISA</button>
            <label for="vmSpeed">Speed (ms per step):</label>
            <input type="number" id="vmSpeed" value="1000" min="50" step="50">

        </div>
    </div>

    <div class="panel-container">
        <div class="panel">
            <h2>Raw Code</h2>
            <textarea id="rawCodeInput" spellcheck="false"></textarea>
            <h2>Output</h2>
            <div id="output" class="txtbx"></div>
            <h2>RAM</h2>
            <div id="ram" class="txtbx"></div>
            <h2>Stack</h2>
            <div id="stack" class="txtbx"></div>

        </div>
        <div class="panel">
            <h2>Registers</h2>
            <div class="registers" id="registers">
                <!-- Registers rendered here -->
            </div>
            <h2>Disassembly</h2>
            <div id="disasm" contenteditable="true" class="disasm-editor" spellcheck="false"></div>
        </div>
    </div>
    <script>
        class MiniMachineVM {
            constructor(program) {
                this.reg = new Array(8).fill(0); // r0-r7
                this.ram = new Array(256).fill(0);
                this.stack = [];
                this.program = program;
                this.halted = false;
                this.PC = 7; // r7 is PC
            }

            fetch() {
                const pc = this.reg[this.PC];
                const idx = pc * 4;
                if (idx + 4 > this.program.length) {
                    this.halted = true;
                    return null;
                }
                return this.program.slice(idx, idx + 4);
            }

            getOperand(val, isImm) {
                return isImm ? val : this.reg[val & 0x7];
            }

            setReg(idx, value) {
                if (idx === 6) return; // r6 is reserved
                this.reg[idx] = value & 0xFF;
            }

            wrt(val, fmt) {
                let ch = "";
                switch (fmt) {
                    case 0:
                        ch = val === 0 ? "\x00" : String.fromCharCode(val);
                        break;
                    case 1:
                        ch = val <= 9 ? val.toString() : "?";
                        break;
                    case 2:
                        ch = val <= 25 ? String.fromCharCode(65 + val) : "?";
                        break;
                    case 3:
                        ch = val <= 15 ? val.toString(16).toUpperCase() : "?";
                        break;
                }
                printOutput(ch);
            }

            execute(instr) {
                const [opcode, op1, op2, dest] = instr;
                const imm1 = (opcode >> 6) & 1;
                const imm2 = (opcode >> 5) & 1;
                const opclass = (opcode >> 3) & 0x3;
                const subtype = opcode & 0x7;

                // ALU
                if (opclass === 0b00) {
                    let a = this.getOperand(op1, imm1);
                    let b = this.getOperand(op2, imm2);
                    let res = 0;
                    switch (subtype) {
                        case 0: res = a & b; break;
                        case 1: res = ((a >>> (b % 8)) | (a << (8 - (b % 8)))) & 0xFF; break;
                        case 2: res = (a + b) & 0xFF; break;
                        case 3: res = a ^ b; break;
                        case 4: res = a | b; break;
                        case 5: res = ((a << (b % 8)) | (a >>> (8 - (b % 8)))) & 0xFF; break;
                        case 6: res = (a - b) & 0xFF; break;
                        case 7: res = (~a) & 0xFF; break;
                    }
                    this.setReg(dest & 0x7, res);
                    this.reg[this.PC] = (this.reg[this.PC] + 1) % 256;
                    return;
                }

                // COND
                if (opclass === 0b01) {
                    let jump = false;
                    let a = this.getOperand(op1, imm1);
                    let b = this.getOperand(op2, imm2);
                    switch (subtype) {
                        case 0: jump = true; break;
                        case 1: jump = a !== b; break;
                        case 2: jump = a >= b; break;
                        case 3: jump = a > b; break;
                        case 4: jump = false; break;
                        case 5: jump = a === b; break;
                        case 6: jump = a < b; break;
                        case 7: jump = a <= b; break;
                    }
                    if (jump) {
                        this.setReg(this.PC, dest);
                    } else {
                        this.reg[this.PC] = (this.reg[this.PC] + 1) % 256;
                    }
                    return;
                }

                // IO
                if (opclass === 0b10) {
                    switch (subtype) {
                        case 0: {
                            const val = this.getOperand(op1, imm1);
                            this.setReg(dest & 0x7, val);
                            break;
                        }
                        case 1: {
                            const idx1 = op1 & 0x7;
                            const idx2 = dest & 0x7;
                            if (idx1 !== 6 && idx2 !== 6) {
                                [this.reg[idx1], this.reg[idx2]] = [this.reg[idx2], this.reg[idx1]];
                            }
                            break;
                        }
                        case 2: {
                            const val = this.getOperand(op1, imm1);
                            this.stack.push(val);
                            break;
                        }
                        case 3: {
                            if (this.stack.length > 0) {
                                this.setReg(dest & 0x7, this.stack.pop());
                            }
                            break;
                        }
                        case 4: {
                            const val = this.getOperand(op1, imm1);
                            const fmt = op2 & 0x3;
                            this.wrt(val, fmt);
                            break;
                        }
                        case 5: {
                            const addr = this.getOperand(op1, imm1);
                            this.stack.push(this.reg[this.PC]);
                            this.setReg(this.PC, addr);
                            return;
                        }
                        case 6: {
                            let offset = this.reg[0];
                            if (offset >= 0x80) offset -= 0x100;
                            this.setReg(this.PC, (this.reg[this.PC] + offset) & 0xFF);
                            return;
                        }
                        case 7: {
                            this.halted = true;
                            return;
                        }
                    }
                    this.reg[this.PC] = (this.reg[this.PC] + 1) % 256;
                }
            }
            renderRegisters() {
                const names = ["r0", "r1", "r2", "r3", "r4", "r5", "r6", "PC"];
                let out = names.map((n, i) => `${n}: ${this.reg[i].toString(16).padStart(2, "0")}`).join("  ");
                document.getElementById("registers").textContent = out;
            }


            run() {
                while (!this.halted) {
                    const instr = this.fetch();
                    if (!instr) break;
                    this.execute(instr);
                }
                printOutput("\n[Program Halted]\n");
            }

            step() {
                if (this.halted) return;
                const instr = this.fetch();
                if (!instr) {
                    this.halted = true;
                    return;
                }
                this.execute(instr);
            }
            disassemble(opcode, op1, op2, dest) {
                const imm1 = (opcode >> 6) & 1;
                const imm2 = (opcode >> 5) & 1;
                const opclass = (opcode >> 3) & 0x3;
                const subtype = opcode & 0x7;

                const regName = idx => `r${idx & 0x7}`;
                const opVal = (val, imm) => imm ? `0x${val.toString(16).toUpperCase().padStart(2, "0")}` : regName(val);

                const immStr = `_${imm1 ? 'i' : 'r'}${imm2 ? 'i' : 'r'}`;

                if (opclass === 0b00) {
                    // ALU
                    const aluOps = ["AND", "ROR", "ADD", "XOR", "OR", "ROL", "SUB", "NOT"];
                    const op = aluOps[subtype] || "???";
                    if (op === "NOT") {
                        return `${op} ${opVal(op1, imm1)}, ${regName(dest)}`;
                    } else {
                        return `${op} ${opVal(op1, imm1)}, ${opVal(op2, imm2)}, ${regName(dest)}`;
                    }
                } else if (opclass === 0b01) {
                    // COND
                    const condOps = ["JMP", "JNE", "JGE", "JGT", "NOP", "JEQ", "JLT", "JLE"];
                    const op = condOps[subtype] || "???";
                    if (op === "JMP") {
                        return `${op} 0x${dest.toString(16).toUpperCase().padStart(2, 0)}`;
                    } else if (op === "NOP") {
                        return `${op}`;
                    } else {
                        return `${op} ${opVal(op1, imm1)}, ${opVal(op2, imm2)}, 0x${dest.toString(16).toUpperCase()}`;
                    }
                } else if (opclass === 0b10) {
                    // IO
                    const ioOps = ["MOV", "SWAP", "PUSH", "POP", "WRT", "CALL", "JRE", "HCF"];
                    const op = ioOps[subtype] || "???";
                    if (op === "MOV") {
                        return `${op} ${opVal(op1, imm1)}, ${regName(dest)}`;
                    } else if (op === "SWAP") {
                        return `${op} ${regName(op1)}, ${regName(dest)}`;
                    } else if (op === "PUSH") {
                        return `${op} ${opVal(op1, imm1)}`;
                    } else if (op === "POP") {
                        return `${op} ${regName(dest)}`;
                    } else if (op === "WRT") {
                        const fmt = op2 & 0x3;
                        let op1Str;
                        let modeComment = "";
                        if (imm1) {
                            if (fmt === 0) { // ASC
                                modeComment = "; ASC";
                                if (op1 === 0) {
                                    op1Str = '0x00';
                                } else if (op1 < 32 || op1 > 126 || op1 === 34 || op1 === 44 || op1 === 32) {
                                    op1Str = `0x${op1.toString(16).toUpperCase().padStart(2, "0")}`;
                                } else {
                                    op1Str = `"${String.fromCharCode(op1)}"`;
                                }
                            } else if (fmt === 1) { // DEC
                                modeComment = "; DEC";
                                op1Str = op1.toString(10);
                            } else if (fmt === 2) { // ALP
                                modeComment = "; ALP";
                                op1Str = op1.toString(10);
                            } else if (fmt === 3) { // HEX
                                modeComment = "; HEX";
                                op1Str = `0x${op1.toString(16).toUpperCase().padStart(2, "0")}`;
                            }
                        } else {
                            op1Str = regName(op1);
                            if (fmt === 0) modeComment = "; ASC";
                            else if (fmt === 1) modeComment = "; DEC";
                            else if (fmt === 2) modeComment = "; ALP";
                            else if (fmt === 3) modeComment = "; HEX";
                        }
                        return `${op} ${op1Str}, 0b${fmt.toString(2).padStart(2, "0")} ${modeComment}`;
                    } else if (op === "CALL") {
                        return `${op} ${opVal(op1, imm1)}`;
                    } else if (op === "JRE" || op === "HCF") {
                        return `${op}`;
                    } else {
                        return `${op} ???`;
                    }
                } else {
                    return "???";
                }
            }
        }
    </script>
    <script>
        const OPCODES = {
            "AND": ["ALU", 0b000], "ROR": ["ALU", 0b001], "ADD": ["ALU", 0b010], "XOR": ["ALU", 0b011],
            "OR": ["ALU", 0b100], "ROL": ["ALU", 0b101], "SUB": ["ALU", 0b110], "NOT": ["ALU", 0b111],
            "JMP": ["COND", 0b000], "JNE": ["COND", 0b001], "JGE": ["COND", 0b010], "JGT": ["COND", 0b011],
            "NOP": ["COND", 0b100], "JEQ": ["COND", 0b101], "JLT": ["COND", 0b110], "JLE": ["COND", 0b111],
            "MOV": ["IO", 0b000], "SWAP": ["IO", 0b001], "PUSH": ["IO", 0b010], "POP": ["IO", 0b011],
            "WRT": ["IO", 0b100], "CALL": ["IO", 0b101], "JRE": ["IO", 0b110], "HCF": ["IO", 0b111],
        };

        const OPCLASS = { "ALU": 0b00, "COND": 0b01, "IO": 0b10 };

        const REGISTERS = {
            "r0": 0, "r1": 1, "r2": 2, "r3": 3,
            "r4": 4, "r5": 5, "r6": 6, "r7": 7,
            "RAMADDR": 4, "RAMDATA": 5, "PC": 7,
        };

        function parseValue(val, constants) {
            val = val.trim();
            if (val in constants) return constants[val];
            if (/^['"](.{1})['"]$/.test(val)) return val.charCodeAt(1);
            if (val.startsWith("0x")) return parseInt(val, 16);
            if (val.startsWith("0b")) return parseInt(val, 2);
            if (/^\d+$/.test(val)) return parseInt(val, 10);
            throw new Error("Unknown value: " + val);
        }

        function isRegister(val) {
            return val in REGISTERS;
        }

        function encodeOpcode(mnemonic, op1, op2) {
            let [cls, subtype] = OPCODES[mnemonic];
            let imm1 = op1 && !isRegister(op1) ? 1 : 0;
            let imm2 = op2 && !isRegister(op2) ? 1 : 0;
            return (imm1 << 6) | (imm2 << 5) | (OPCLASS[cls] << 3) | subtype;
        }

        function encodeOperand(val, constants) {
            if (!val) return 0;
            return isRegister(val) ? REGISTERS[val] : (parseValue(val, constants) & 0xFF);
        }

        function handleShorthand(op, args) {
            args = [...args];
            if (op === "MOV" && args.length === 2) args.splice(1, 0, "0");
            else if (op === "HCF") args = ["0", "0", "0"];
            else if (op === "WRT" && args.length === 1) args.push("0", "0");
            else if (op === "WRT" && args.length === 2) args.push("0");
            else if (op === "PUSH" && args.length === 1) args.push("0", "0");
            else if (op === "POP" && args.length === 1) args = ["0", "0", args[0]];
            else if (op === "JMP" && args.length === 1) args = ["0", "0", args[0]];
            else if (op === "CALL" && args.length === 1) args.push("0", "0");
            return args;
        }

        function assemble() {
            const disasmEl = document.getElementById("disasm");
            const rawCodeInput = document.getElementById("rawCodeInput");
            const lines = disasmEl.innerText.split("\n");
            console.log(lines)

            let constants = {}, macros = {}, labels = {}, pc = 0, code = [];
            let expanded = [], unresolved = [];

            // --- First pass: Constants/Macros ---
            for (let i = 0; i < lines.length;) {
                let line = lines[i].split(";")[0].trim();
                if (!line) { i++; continue; }

                const defineMatch = line.match(/^define\s+(\w+)(\((.*?)\))?(\:)?\s*(.*)?/);
                if (defineMatch) {
                    const [_, name, __, argstr, colon, body] = defineMatch;
                    const macroArgs = argstr ? argstr.split(",").map(s => s.trim()) : [];
                    if (colon) {
                        const macroLines = [];
                        i++;
                        while (i < lines.length && lines[i].trim() !== "end") {
                            if (!lines[i].startsWith("define")) macroLines.push(lines[i].split(";")[0].trim());
                            i++;
                        }
                        macros[name.toUpperCase()] = [macroArgs, macroLines];
                        i++;
                        continue;
                    } else {
                        constants[name] = parseValue(body, constants);
                        i++;
                        continue;
                    }
                }

                expanded.push(line);
                pc++;
                i++;
            }

            // --- Macro expansion ---
            function expandMacros(lines, parentArgs = {}) {
                const result = [];
                for (let line of lines) {
                    const tokens = line.trim().split(/[,\s]+/);
                    const mnemonic = tokens[0].toUpperCase();
                    if (macros[mnemonic]) {
                        const [macroArgs, macroBody] = macros[mnemonic];
                        const actualArgs = tokens.slice(1, 1 + macroArgs.length);
                        const argMap = Object.fromEntries(macroArgs.map((k, i) => [k, actualArgs[i]]));

                        const substitute = str => {
                            for (let [k, v] of Object.entries(argMap)) str = str.replaceAll(k, v);
                            for (let [k, v] of Object.entries(parentArgs)) str = str.replaceAll(k, v);
                            return str;
                        };

                        const body = macroBody.map(substitute);
                        result.push(...expandMacros(body, argMap));
                    } else {
                        for (let [k, v] of Object.entries(parentArgs)) line = line.replaceAll(k, v);
                        result.push(line);
                    }
                }
                return result;
            }

            expanded = expandMacros(expanded);

            // --- Second pass: Assemble ---
            pc = 0;
            const output = [];

            for (let line of expanded) {
                while (line.match(/^(\w+):\s*(.*)/)) {
                    const m = line.match(/^(\w+):\s*(.*)/);
                    if (!m) break;
                    line = m[2];
                }

                if (!line.trim()) continue;

                const tokens = line.trim().split(/[,\s]+/);
                const mnemonic = tokens[0].toUpperCase();

                if (mnemonic === "LABEL") {
                    const label = tokens[1].replace(/:$/, '');
                    labels[label] = pc;
                    constants[label] = pc;
                    continue;
                }

                let args = handleShorthand(mnemonic, tokens.slice(1));
                for (let i = 0; i < 3; i++) {
                    if (args[i] in labels) args[i] = labels[args[i]].toString();
                    else if (args[i]?.startsWith("$")) {
                        unresolved.push([output.length, i, args[i].slice(1)]);
                        args[i] = "0";
                    }
                }

                if (!(mnemonic in OPCODES)) throw new Error("Unknown mnemonic: " + mnemonic);
                const [op1, op2, dest] = args;
                const b1 = encodeOpcode(mnemonic, op1, op2);
                const b2 = encodeOperand(op1, constants);
                const b3 = encodeOperand(op2, constants);
                const b4 = encodeOperand(dest, constants);
                output.push([b1, b2, b3, b4]);
                pc++;
            }

            // --- Resolve labels ---
            for (const [idx, argIdx, label] of unresolved) {
                if (!("$" + label in labels)) throw new Error("Undefined label: " + label);
                output[idx][argIdx + 1] = labels["$" + label] & 0xFF;
            }

            // --- Emit ---
            const hex = output.flat().map(b => b.toString(16).padStart(2, '0')).join(" ");
            rawCodeInput.value = hex;
        }

    </script>
    <script>
        let interval = null;
        let vm = null;
        // Keep track of previous register values
        const previousRegs = {};

        const playPauseBtn = document.getElementById('playPauseBtn');
        const stepBtn = document.getElementById('stepBtn');
        const assembleBtn = document.getElementById('assembleBtn');

        const rawCodeInput = document.getElementById('rawCodeInput');
        const disasmEl = document.getElementById('disasm');

        const registersEl = document.getElementById('registers');
        const documentationButton = document.getElementById("documentation")
        const speedInput = document.getElementById("vmSpeed")

        const outputEl = document.getElementById("output")
        const RAMEl = document.getElementById("ram")
        const stackEl = document.getElementById("stack")

        render()
        function printOutput(output) {
            if (output === "\x00") {
                outputEl.innerText = ""
            }
            else {
                outputEl.innerText += output
            }
        }
        documentationButton.addEventListener("click", () => {
            window.open("/Mini-8/ISA")
        })
        function startVMInterval(delay) {
            if (interval) clearInterval(interval);
            interval = setInterval(() => {
                vm.step();
                render();
                if (vm.halted) {
                    clearInterval(interval);
                    interval = null;
                    playPauseBtn.textContent = 'Play';
                }
            }, delay);
        }

        playPauseBtn.addEventListener('click', () => {
            if (interval) {
                clearInterval(interval);
                interval = null;
                playPauseBtn.textContent = 'Play';
            } else {
                if (!vm) loadVMFromRaw();
                const delay = parseInt(speedInput.value, 10) || 1000;
                startVMInterval(delay);
                playPauseBtn.textContent = 'Pause';
            }
        });

        // Change VM speed while running
        speedInput.addEventListener('input', () => {
            if (interval) {
                const delay = parseInt(speedInput.value, 10) || 1000;
                startVMInterval(delay); // restart with new speed
            }
        });


        const fileInput = document.getElementById('fileInput');
        const loadBtn = document.getElementById('loadBtn');

        loadBtn.addEventListener('click', () => {
            fileInput.click();
        });
        assembleBtn.addEventListener("click", () => {
            assemble()
        })

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (evt) {
                const buffer = evt.target.result;
                // Convert ArrayBuffer to hex string
                const bytes = new Uint8Array(buffer);
                const text = Array.from(bytes)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join(' ');
                rawCodeInput.value = text;
                vm = null;
                updateDisassembly(0);
            };
            reader.readAsArrayBuffer(file);
        });
        stepBtn.addEventListener('click', () => {
            if (!vm) loadVMFromRaw();
            vm.step();
            render();
        });

        rawCodeInput.addEventListener('input', () => {
            vm = null; // Reset VM when code changes
            updateDisassembly(0);
        });
        rawCodeInput.addEventListener('dragover', (e) => {
            e.preventDefault();
            rawCodeInput.style.background = '#222'; // Visual feedback
        });

        rawCodeInput.addEventListener('dragleave', (e) => {
            e.preventDefault();
            rawCodeInput.style.background = '#000';
        });

        rawCodeInput.addEventListener('drop', (e) => {
            e.preventDefault();
            rawCodeInput.style.background = '#000';
            const file = e.dataTransfer.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (evt) {
                const buffer = evt.target.result;
                // Convert ArrayBuffer to hex string
                const bytes = new Uint8Array(buffer);
                const text = Array.from(bytes)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join(' ');
                rawCodeInput.value = text;
                vm = null;
                updateDisassembly(0);
            };
            reader.readAsArrayBuffer(file);
        });

        const formatBtn = document.getElementById('formatBtn');
        formatBtn.addEventListener('click', () => {
            // Remove all non-hex chars and condense to a single string
            let hexStr = rawCodeInput.value.replace(/[^0-9a-fA-F]/g, '').toUpperCase();

            // Split into 2-char bytes
            let bytes = [];
            for (let i = 0; i < hexStr.length; i += 2) {
                bytes.push(hexStr.substr(i, 2));
            }

            // Format into lines of 4 bytes each
            let lines = [];
            for (let i = 0; i < bytes.length; i += 4) {
                lines.push(bytes.slice(i, i + 4).join(' '));
            }
            rawCodeInput.value = lines.join('\n');
            vm = null;
            updateDisassembly(0);
        });

        function loadVMFromRaw() {
            const bytes = rawCodeInput.value
                .trim()
                .split(/\s+/)
                .map(b => parseInt(b, 16) || 0);
            vm = new MiniMachineVM(new Uint8Array(bytes));
            render();
        }

        function updateDisassembly(currentPC = null) {
            const bytes = rawCodeInput.value
                .trim()
                .split(/\s+/)
                .map(b => parseInt(b, 16) || 0);

            disasmEl.innerHTML = '';
            for (let i = 0, line = 1; i + 3 < bytes.length; i += 4, line++) {
                const instr = bytes.slice(i, i + 4);
                const dis = MiniMachineVM.prototype.disassemble(...instr);
                const isCurrent = currentPC !== null && (i / 4) === currentPC;

                const lineEl = document.createElement('div');
                lineEl.className = 'dis-line';
                if (isCurrent) lineEl.classList.add('current-pc');
                lineEl.dataset.line = line.toString(16).padStart(2, '0').toUpperCase();
                lineEl.textContent = dis;

                disasmEl.appendChild(lineEl);
            }

        }


        function render() {
            const names = ['r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'PC'];
            registersEl.innerHTML = '';

            names.forEach((n, i) => {
                if (n === 'r6') return;

                const val = vm ? vm.reg[i].toString(16).padStart(2, '0') : '00';
                const div = document.createElement('div');
                div.className = 'register';
                div.textContent = `${n}: 0x${val}`;

                // Compare to previous value and flash if changed
                if (previousRegs[n] !== val) {
                    div.classList.add('flash');
                    setTimeout(() => div.classList.remove('flash'), 300); // adjust duration as needed
                }

                // Update stored value
                previousRegs[n] = val;

                registersEl.appendChild(div);
            });
            // Function to convert a number to a 2-digit hex string
            function toHex(byte) {
                return byte.toString(16).toUpperCase().padStart(2, '0');
            }

            // Update RAMEl with hex pairs from vm.ram
            RAMEl.innerText = vm ? vm.ram.map(toHex).join(' ') : "";

            // Update stackEl with hex pairs from vm.stack
            stackEl.innerText = vm ? vm.stack.map(toHex).join(' ') : "";

            updateDisassembly(vm ? vm.reg[7] : null);
        }


        render()

    </script>
</body>

</html>