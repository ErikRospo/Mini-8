MOV 1, r0 ; counter
label $outerloop

MOV 0, r1 ; result
MOV 0x40, r2 ; bit to check
label $innerloop
    ADD r1, r2, r3 ; r3=res+bit

    PUSH r2
    PUSH r1
    PUSH r0
    MOV r3, r0 
    MOV r3, r1
    CALL $mult ; r2=r3*r3
    ;stack is r2 (bit), r1 (result), r0 (counter) in order
    POP r0 
    ;stack is r2 (bit), r1 (result), in order
    JGT r3 r0 $skipset
    POP r1 ;This will actually just get overwritten, we just need it off the stack
    PUSH r3 ; Push tmp so when we pop r1 back, it's actually tmp
    
label $skipset
    POP r1
    POP r2
    ROR r2, 1, r2 
    AND r2, 0x7F, r2 ; Mask and rotate for shift

    JNE r2, 0, $innerloop ; as long as the bit we're checking is not 0, jump back up
    WRT "s", 0b00
    WRT "q", 0b00
    WRT "r", 0b00
    WRT "t", 0b00
    WRT "(", 0b00
    CALL $decprint
    WRT ")", 0b00
    WRT "~", 0b00
    WRT "=", 0b00
    SWAP r0, r1
    CALL $decprint
    SWAP r0, r1 ; swap result and counter
    WRT 10, 0b00 ; newline
    ADD r0, 1, r0 ;Add one to the counter and jump up
    JEQ r0, 0, $exit ; If it's zero, we've overflowed, and thus reached all 256 numbers
    JMP $outerloop

label $mult ; mult implementation
    ; R2 = R0*R1
    ; clobbers R2
    PUSH r0
    PUSH r1 
    MOV 0, r2
label $mult_loop
    ADD r2, r0, r2;
    SUB r1, 1, r1
    JNE r1, 0, $mult_loop

label $mult_done
    POP r1
    POP r0 
    POP r7 ; ret


label $decprint: ; print a number in decimal
    PUSH r2
    PUSH r1
    PUSH r0

    MOV 0, r2
    
label $hundreds_loop
    JLT r0, 100, $after_hundreds
    SUB r0, 100, r0
    ADD r2, 1, r2
    JMP $hundreds_loop

label $after_hundreds
    WRT r2, 0b01 ; DEC output

    MOV 0, r2

label $tens_loop
    JLT r0, 10, $after_tens
    SUB r0, 10, r0
    ADD r2, 1, r2
    JMP $tens_loop

label $after_tens
    WRT r2, 0b01
    WRT r0, 0b01

    POP r0
    POP r1
    POP r2
    POP r7 ; RET 

label $exit
    HCF