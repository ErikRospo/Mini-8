; This version treats 1 as a prime number, which is not technically correct,
; but avoids having to program in a special case for 1.

MOV 1, r0 ; r0 is our number

label $outerloop:
    MOV 2, r1 ; start divisor at 2
    AND r0, 0xFE, r3
    ROR r3, 1, r3 ; r3 = r0 / 2

label $innerloop:

    JGT r1, r3, $innerloop_prime ; if divisor > upper bound, it's a prime
    CALL $modulo ; r0 mod r1, result in r2
    JEQ r2, 0, $innerloop_composite ; If we've found a divisor, end early.
    ADD r1, 1, r1 ; increment divisor
    JMP $innerloop ; repeat

label $innerloop_composite:
    WRT "C", 0b00 ;C: in ascii mode
    WRT ":", 0b00 
    JMP $innerloop_done

label $innerloop_prime:
    WRT "P", 0b00 ;P: in ascii mode
    WRT ":", 0b00 

label $innerloop_done:
    CALL $decprint ;Print the number
    WRT 10, 0b00 ; newline

    ADD r0, 1, r0 ; add one and if we've overflowed, halt
    JNE r0, 0, $outerloop
    HCF

; n/2 == ROR + AND 7f

label $modulo ; modulo implementation
    ; R2 = R0 mod R1
    ; clobbers R2
    PUSH r0
    PUSH r1 
    MOV r0, r2
label $modulo_loop
    JLT r2, r1, $mod_done
    SUB r2, r1, r2;
    JMP $modulo_loop

label $mod_done
    POP r1
    POP r0 
    POP r7 ; ret


label $decprint: ; Decimal Printing implementation
    PUSH r2
    PUSH r1
    PUSH r0

    MOV 0, r2
    
label $hundreds_loop:
    JLT r0, 100, $after_hundreds
    SUB r0, 100, r0
    ADD r2, 1, r2
    JMP $hundreds_loop

label $after_hundreds:
    WRT r2, 0b01 ; DEC output

    MOV 0, r2

label $tens_loop:
    JLT r0, 10, $after_tens
    SUB r0, 10, r0
    ADD r2, 1, r2
    JMP $tens_loop

label $after_tens:
    WRT r2, 0b01
    WRT r0, 0b01

    POP r0
    POP r1
    POP r2
    POP r7 ; RET 

